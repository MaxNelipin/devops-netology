#1.

- Электронные чеки в json виде - Документоориентированная, т.к. можно хранить неструктурированные позиции чека
- Склады и автомобильные дороги для логистической компании - Графовая для постороения путей между складами при перемещении товара
- Генеалогические деревья - Иерархическая, птому что всегда один родитель
- Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации - REDIS, потому что обеспечивает постоянство, чтобы не потерять товары клиента
- Отношения клиент-покупка для интернет-магазина - Можно реляционную (id клиента - id покупки - купленные товары) 
      или ключ-значение, если можем хранить в значении, например, json

#2.
CAP
- Данные записываются на все узлы с задержкой до часа (асинхронная запись) - CA, т.к. при расщеплении куда-то данные могут не записаться
- При сетевых сбоях, система может разделиться на 2 раздельных кластера - AP, т.к. нет согласованности 
- Система может не прислать корректный ответ или сбросить соединение - CP, т.к. нет гарантии отклика 

PACELC
  
- Данные записываются на все узлы с задержкой до часа (асинхронная запись) - PA/EL, т.к. здесь согласованность данных при нормальной работе и доступность при разделении
- При сетевых сбоях, система может разделиться на 2 раздельных кластера - PA/EC, т.к. может разделиться и остаться доступной, но при нормальной работе будет согласована 
- Система может не прислать корректный ответ или сбросить соединение - PC/EC, т.к. нет гарантии отклика  


#3.
Можно совмещать частично модели, например, делать атомарные транзакции, но согласованность узлов обеспечивать по BASE, 
т.е. когда-нибудь или по событию чтения. Полностью совместить не удастся, потому что согласованности в момент окончания транзакции 
придётся ждать некоторое время, что для некоторых систем недупстимо, например, финансовых.

#4
Redis
- Размер БД ограничен объёмом ОЗУ, шардинг ведёт к задержкам 
- Отсутствует контроль доступа, пользователи и группы
- Нет структурированного языка, разработчик должен сам заботиться как получать доступ к данным
